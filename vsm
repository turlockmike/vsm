#!/usr/bin/env python3
"""
VSM CLI — User-facing command-line interface for the Viable System Machine
"""

import argparse
import json
import os
import sys
import glob
from datetime import datetime
from pathlib import Path
import subprocess

# ANSI color codes
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    RESET = '\033[0m'

def find_vsm_root():
    """Auto-detect VSM_ROOT by looking for core/controller.py"""
    # Check script's directory
    script_dir = Path(__file__).parent.resolve()
    if (script_dir / 'core' / 'controller.py').exists():
        return script_dir

    # Check ~/vsm
    home_vsm = Path.home() / 'vsm'
    if (home_vsm / 'core' / 'controller.py').exists():
        return home_vsm

    # Check ~/projects/vsm/main
    projects_vsm = Path.home() / 'projects' / 'vsm' / 'main'
    if (projects_vsm / 'core' / 'controller.py').exists():
        return projects_vsm

    print(f"{Colors.RED}Error: Could not find VSM installation{Colors.RESET}")
    print(f"Looked in: {script_dir}, {home_vsm}, {projects_vsm}")
    sys.exit(1)

VSM_ROOT = find_vsm_root()
TASKS_DIR = VSM_ROOT / 'sandbox' / 'tasks'
STATE_FILE = VSM_ROOT / 'state' / 'state.json'
LOGS_DIR = VSM_ROOT / 'state' / 'logs'
HEARTBEAT_SCRIPT = VSM_ROOT / 'heartbeat.sh'

def get_next_task_id():
    """Find the next available task ID by scanning existing tasks"""
    task_files = glob.glob(str(TASKS_DIR / '*.json'))
    if not task_files:
        return "001"

    max_id = 0
    for task_file in task_files:
        try:
            with open(task_file, 'r') as f:
                task = json.load(f)
                task_id = int(task.get('id', '0'))
                max_id = max(max_id, task_id)
        except (json.JSONDecodeError, ValueError):
            continue

    return f"{max_id + 1:03d}"

def task_add(args):
    """Add a new task"""
    if not TASKS_DIR.exists():
        TASKS_DIR.mkdir(parents=True, exist_ok=True)

    task_id = get_next_task_id()
    title = args.title
    description = args.description if args.description else title
    priority = args.priority

    task = {
        "id": task_id,
        "priority": priority,
        "title": title,
        "description": description,
        "created": datetime.now().isoformat(timespec='seconds'),
        "status": "pending"
    }

    # Create filename from title (sanitized)
    filename_base = title.lower()[:30].replace(' ', '_')
    filename_base = ''.join(c for c in filename_base if c.isalnum() or c == '_')
    filename = TASKS_DIR / f"{task_id}_{filename_base}.json"

    with open(filename, 'w') as f:
        json.dump(task, f, indent=2)

    print(f"{Colors.GREEN}✓ Task created{Colors.RESET}")
    print(f"  ID: {Colors.BOLD}{task_id}{Colors.RESET}")
    print(f"  Title: {title}")
    print(f"  Priority: {priority}")
    print(f"  File: {filename.name}")

def task_list(args):
    """List all tasks"""
    task_files = sorted(glob.glob(str(TASKS_DIR / '*.json')))

    if not task_files:
        print(f"{Colors.YELLOW}No tasks found{Colors.RESET}")
        return

    tasks = []
    for task_file in task_files:
        try:
            with open(task_file, 'r') as f:
                task = json.load(f)
                tasks.append(task)
        except json.JSONDecodeError:
            continue

    # Sort by priority (lower number = higher priority), then by ID
    tasks.sort(key=lambda t: (t.get('priority', 999), t.get('id', '999')))

    # Print header
    print(f"\n{Colors.BOLD}{'ID':<5} {'PRI':<5} {'STATUS':<12} {'CREATED':<12} {'TITLE'}{Colors.RESET}")
    print("─" * 80)

    # Print tasks
    for task in tasks:
        task_id = task.get('id', '?')
        priority = task.get('priority', '?')
        status = task.get('status', 'unknown')
        created = task.get('created', '')[:10]  # Just the date part
        title = task.get('title', 'Untitled')[:50]  # Truncate long titles

        # Color code status
        if status == 'pending':
            status_colored = f"{Colors.YELLOW}{status:<12}{Colors.RESET}"
        elif status == 'done' or status == 'complete':
            status_colored = f"{Colors.GREEN}{status:<12}{Colors.RESET}"
        elif status == 'in_progress':
            status_colored = f"{Colors.CYAN}{status:<12}{Colors.RESET}"
        else:
            status_colored = f"{status:<12}"

        print(f"{task_id:<5} {priority:<5} {status_colored} {created:<12} {title}")

    print()

def show_status(args):
    """Show system status"""
    if not STATE_FILE.exists():
        print(f"{Colors.RED}Error: State file not found at {STATE_FILE}{Colors.RESET}")
        sys.exit(1)

    with open(STATE_FILE, 'r') as f:
        state = json.load(f)

    print(f"\n{Colors.BOLD}{Colors.BLUE}═══ VSM SYSTEM STATUS ═══{Colors.RESET}\n")

    # Core metrics
    cycle_count = state.get('cycle_count', 0)
    criticality = state.get('criticality', 0)
    last_action = state.get('last_action', 'No action recorded')
    last_success = state.get('last_result_success', None)
    updated = state.get('updated', '')[:19]  # Trim microseconds

    print(f"{Colors.BOLD}Cycle Count:{Colors.RESET}     {cycle_count}")
    print(f"{Colors.BOLD}Criticality:{Colors.RESET}     {criticality:.2f}")
    print(f"{Colors.BOLD}Last Updated:{Colors.RESET}    {updated}")

    # Success indicator
    if last_success is True:
        success_indicator = f"{Colors.GREEN}✓ Success{Colors.RESET}"
    elif last_success is False:
        success_indicator = f"{Colors.RED}✗ Failed{Colors.RESET}"
    else:
        success_indicator = f"{Colors.DIM}Unknown{Colors.RESET}"
    print(f"{Colors.BOLD}Last Result:{Colors.RESET}     {success_indicator}")

    print(f"{Colors.BOLD}Last Action:{Colors.RESET}     {last_action[:70]}")
    if len(last_action) > 70:
        print(f"                {last_action[70:]}")

    # Health metrics
    health = state.get('health', {})
    if health:
        print(f"\n{Colors.BOLD}Health Metrics:{Colors.RESET}")
        disk_free = health.get('disk_free_gb', 0)
        disk_pct = health.get('disk_pct_used', 0)
        mem_available = health.get('mem_available_mb', 0)
        pending_tasks = health.get('pending_tasks', 0)
        cron_installed = health.get('cron_installed', False)

        print(f"  Disk:          {disk_free:.1f} GB free ({disk_pct:.1f}% used)")
        print(f"  Memory:        {mem_available} MB available")
        print(f"  Pending Tasks: {pending_tasks}")
        print(f"  Cron:          {Colors.GREEN if cron_installed else Colors.RED}{'Installed' if cron_installed else 'Not installed'}{Colors.RESET}")

    # Errors
    errors = state.get('errors', [])
    if errors:
        print(f"\n{Colors.BOLD}{Colors.RED}Errors ({len(errors)}):{Colors.RESET}")
        for i, error in enumerate(errors[:5], 1):
            print(f"  {i}. {error}")
        if len(errors) > 5:
            print(f"  ... and {len(errors) - 5} more")
    else:
        print(f"\n{Colors.GREEN}No errors recorded{Colors.RESET}")

    print()

def show_logs(args):
    """Show recent log entries"""
    if not LOGS_DIR.exists():
        print(f"{Colors.RED}Error: Logs directory not found at {LOGS_DIR}{Colors.RESET}")
        sys.exit(1)

    # Filter out heartbeat.log (plain text, not JSON cycle logs)
    log_files = sorted(
        [f for f in glob.glob(str(LOGS_DIR / '*.log')) if not f.endswith('heartbeat.log')],
        key=os.path.getmtime, reverse=True
    )

    if not log_files:
        print(f"{Colors.YELLOW}No logs found{Colors.RESET}")
        return

    limit = args.n if hasattr(args, 'n') and args.n else 5
    log_files = log_files[:limit]

    print(f"\n{Colors.BOLD}{Colors.BLUE}═══ RECENT LOGS (last {len(log_files)}) ═══{Colors.RESET}\n")

    for log_file in log_files:
        try:
            with open(log_file, 'r') as f:
                log_data = json.load(f)

            timestamp = log_data.get('timestamp', '')[:19]
            mode = log_data.get('mode', 'unknown')
            success = log_data.get('success', None)
            summary = log_data.get('summary', 'No summary')
            reason = log_data.get('reason', '')

            # Color code success
            if success is True:
                success_indicator = f"{Colors.GREEN}✓{Colors.RESET}"
            elif success is False:
                success_indicator = f"{Colors.RED}✗{Colors.RESET}"
            else:
                success_indicator = f"{Colors.YELLOW}?{Colors.RESET}"

            print(f"{success_indicator} {Colors.BOLD}{timestamp}{Colors.RESET} [{Colors.CYAN}{mode}{Colors.RESET}]")
            if reason:
                print(f"  Reason: {Colors.DIM}{reason}{Colors.RESET}")

            # Show summary preview (first line or first 100 chars)
            summary_lines = summary.split('\n')
            summary_preview = summary_lines[0][:100]
            print(f"  {summary_preview}")
            if len(summary_lines) > 1:
                print(f"  {Colors.DIM}... (+{len(summary_lines) - 1} more lines){Colors.RESET}")
            print()

        except (json.JSONDecodeError, IOError) as e:
            print(f"{Colors.RED}Error reading {os.path.basename(log_file)}: {e}{Colors.RESET}\n")
            continue

    print()

def run_heartbeat(args):
    """Manually trigger a heartbeat cycle"""
    if not HEARTBEAT_SCRIPT.exists():
        print(f"{Colors.RED}Error: Heartbeat script not found at {HEARTBEAT_SCRIPT}{Colors.RESET}")
        sys.exit(1)

    print(f"{Colors.CYAN}Starting heartbeat cycle...{Colors.RESET}\n")

    try:
        result = subprocess.run(
            ['bash', str(HEARTBEAT_SCRIPT)],
            cwd=str(VSM_ROOT),
            capture_output=False,
            text=True
        )

        if result.returncode == 0:
            print(f"\n{Colors.GREEN}✓ Heartbeat completed{Colors.RESET}")
        else:
            print(f"\n{Colors.RED}✗ Heartbeat failed (exit code {result.returncode}){Colors.RESET}")
            sys.exit(result.returncode)

    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}Interrupted{Colors.RESET}")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Colors.RED}Error running heartbeat: {e}{Colors.RESET}")
        sys.exit(1)

def run_dashboard(args):
    """Start the web dashboard"""
    dashboard_script = VSM_ROOT / 'core' / 'dashboard.py'

    if not dashboard_script.exists():
        print(f"{Colors.RED}Error: Dashboard script not found at {dashboard_script}{Colors.RESET}")
        sys.exit(1)

    try:
        subprocess.run(['python3', str(dashboard_script)], cwd=str(VSM_ROOT))
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}Dashboard stopped{Colors.RESET}")
    except Exception as e:
        print(f"\n{Colors.RED}Error running dashboard: {e}{Colors.RESET}")
        sys.exit(1)

def email_scan(args):
    """Scan inbox and classify emails"""
    triage_script = VSM_ROOT / 'core' / 'gmail_triage.py'
    try:
        subprocess.run(['python3', str(triage_script), 'scan'], cwd=str(VSM_ROOT))
    except Exception as e:
        print(f"\n{Colors.RED}Error running email scan: {e}{Colors.RESET}")
        sys.exit(1)

def email_digest(args):
    """Show daily email digest"""
    triage_script = VSM_ROOT / 'core' / 'gmail_triage.py'
    try:
        subprocess.run(['python3', str(triage_script), 'digest'], cwd=str(VSM_ROOT))
    except Exception as e:
        print(f"\n{Colors.RED}Error running email digest: {e}{Colors.RESET}")
        sys.exit(1)

def email_setup(args):
    """Run Gmail OAuth setup"""
    triage_script = VSM_ROOT / 'core' / 'gmail_triage.py'
    try:
        subprocess.run(['python3', str(triage_script), 'setup'], cwd=str(VSM_ROOT))
    except Exception as e:
        print(f"\n{Colors.RED}Error running email setup: {e}{Colors.RESET}")
        sys.exit(1)

def inbox_list(args):
    """List unread emails from inbox/ directory"""
    inbox_dir = VSM_ROOT / 'inbox'

    if not inbox_dir.exists():
        print(f"{Colors.YELLOW}No inbox directory found{Colors.RESET}")
        return

    unread_files = []
    for filepath in inbox_dir.glob('*.txt'):
        content = filepath.read_text()
        if 'Status: unread' in content:
            unread_files.append(filepath)

    if not unread_files:
        print(f"{Colors.GREEN}No unread emails{Colors.RESET}")
        return

    print(f"\n{Colors.BOLD}{Colors.BLUE}═══ INBOX ({len(unread_files)} unread) ═══{Colors.RESET}\n")

    for filepath in sorted(unread_files):
        # Parse email file
        content = filepath.read_text()
        lines = content.split('\n')

        thread_id = ""
        sender = ""
        subject = ""
        date = ""

        for line in lines:
            if line.startswith('Thread-ID:'):
                thread_id = line.split(':', 1)[1].strip()
            elif line.startswith('From:'):
                sender = line.split(':', 1)[1].strip()
                if '<' in sender:
                    sender = sender.split('<')[0].strip()
            elif line.startswith('Subject:'):
                subject = line.split(':', 1)[1].strip()
            elif line.startswith('Date:'):
                date = line.split(':', 1)[1].strip()[:16]  # Just date + time

        print(f"{Colors.BOLD}{thread_id[:8]}{Colors.RESET} | {Colors.CYAN}{sender[:30]:<30}{Colors.RESET}")
        print(f"         {Colors.DIM}{date}{Colors.RESET}")
        print(f"         {subject[:70]}")
        print()

def inbox_sync(args):
    """Manually trigger maildir sync"""
    maildir_script = VSM_ROOT / 'core' / 'maildir.py'

    print(f"{Colors.CYAN}Syncing inbox...{Colors.RESET}\n")

    try:
        subprocess.run(['python3', str(maildir_script), 'sync'], cwd=str(VSM_ROOT))
        print(f"\n{Colors.GREEN}✓ Sync complete{Colors.RESET}")
    except Exception as e:
        print(f"\n{Colors.RED}Error running sync: {e}{Colors.RESET}")
        sys.exit(1)

def inbox_reply(args):
    """Write reply to outbox/ directory"""
    inbox_dir = VSM_ROOT / 'inbox'
    outbox_dir = VSM_ROOT / 'outbox'

    thread_id = args.thread_id
    message = args.message

    # Find the email file for this thread
    email_file = None
    for filepath in inbox_dir.glob(f"{thread_id}*.txt"):
        email_file = filepath
        break

    if not email_file:
        print(f"{Colors.RED}Error: Email thread {thread_id} not found in inbox{Colors.RESET}")
        sys.exit(1)

    # Parse email to get sender and subject
    content = email_file.read_text()
    lines = content.split('\n')

    sender = ""
    subject = ""

    for line in lines:
        if line.startswith('From:'):
            sender = line.split(':', 1)[1].strip()
            # Extract email address if in "Name <email>" format
            if '<' in sender and '>' in sender:
                sender = sender.split('<')[1].split('>')[0].strip()
        elif line.startswith('Subject:'):
            subject = line.split(':', 1)[1].strip()

    if not sender:
        print(f"{Colors.RED}Error: Could not parse sender from email file{Colors.RESET}")
        sys.exit(1)

    # Write reply to outbox
    outbox_dir.mkdir(parents=True, exist_ok=True)

    reply_file = outbox_dir / f"{thread_id}_reply.txt"
    reply_content = f"""Thread-ID: {thread_id}
To: {sender}
Subject: Re: {subject}
---
{message}
"""

    reply_file.write_text(reply_content)

    print(f"{Colors.GREEN}✓ Reply queued{Colors.RESET}")
    print(f"  Thread: {thread_id}")
    print(f"  To: {sender}")
    print(f"  File: {reply_file.name}")
    print(f"\n{Colors.DIM}Run 'vsm inbox sync' to send{Colors.RESET}")

def main():
    parser = argparse.ArgumentParser(
        description='VSM — Viable System Machine CLI',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # Task command group
    task_parser = subparsers.add_parser('task', help='Manage tasks')
    task_subparsers = task_parser.add_subparsers(dest='task_command')

    # task add
    add_parser = task_subparsers.add_parser('add', help='Add a new task')
    add_parser.add_argument('title', help='Task title')
    add_parser.add_argument('--description', help='Task description (defaults to title)')
    add_parser.add_argument('--priority', type=int, default=5, help='Task priority (default: 5)')
    add_parser.set_defaults(func=task_add)

    # task list
    list_parser = task_subparsers.add_parser('list', help='List all tasks')
    list_parser.set_defaults(func=task_list)

    # status
    status_parser = subparsers.add_parser('status', help='Show system status')
    status_parser.set_defaults(func=show_status)

    # logs
    logs_parser = subparsers.add_parser('logs', help='Show recent log entries')
    logs_parser.add_argument('-n', type=int, default=5, help='Number of logs to show (default: 5)')
    logs_parser.set_defaults(func=show_logs)

    # run
    run_parser = subparsers.add_parser('run', help='Manually trigger a heartbeat cycle')
    run_parser.set_defaults(func=run_heartbeat)

    # dashboard
    dashboard_parser = subparsers.add_parser('dashboard', help='Start the web dashboard')
    dashboard_parser.set_defaults(func=run_dashboard)

    # email command group
    email_parser = subparsers.add_parser('email', help='Manage email triage')
    email_subparsers = email_parser.add_subparsers(dest='email_command')

    # email scan
    email_scan_parser = email_subparsers.add_parser('scan', help='Scan inbox and classify emails')
    email_scan_parser.set_defaults(func=email_scan)

    # email digest
    email_digest_parser = email_subparsers.add_parser('digest', help='Show daily email digest')
    email_digest_parser.set_defaults(func=email_digest)

    # email setup
    email_setup_parser = email_subparsers.add_parser('setup', help='Run Gmail OAuth setup')
    email_setup_parser.set_defaults(func=email_setup)

    # inbox command group
    inbox_parser = subparsers.add_parser('inbox', help='Manage email inbox (Maildir)')
    inbox_subparsers = inbox_parser.add_subparsers(dest='inbox_command')

    # inbox (list)
    inbox_list_parser = inbox_subparsers.add_parser('list', help='List unread emails')
    inbox_list_parser.set_defaults(func=inbox_list)

    # inbox sync
    inbox_sync_parser = inbox_subparsers.add_parser('sync', help='Sync inbox with agentmail')
    inbox_sync_parser.set_defaults(func=inbox_sync)

    # inbox reply
    inbox_reply_parser = inbox_subparsers.add_parser('reply', help='Reply to an email')
    inbox_reply_parser.add_argument('thread_id', help='Thread ID to reply to')
    inbox_reply_parser.add_argument('message', help='Reply message')
    inbox_reply_parser.set_defaults(func=inbox_reply)

    # Default inbox command is list
    inbox_parser.set_defaults(func=inbox_list)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    if args.command == 'task' and not args.task_command:
        task_parser.print_help()
        sys.exit(1)

    if args.command == 'email' and not args.email_command:
        email_parser.print_help()
        sys.exit(1)

    if args.command == 'inbox' and not args.inbox_command:
        # Default to list if no subcommand
        args.func = inbox_list

    # Execute the command
    if hasattr(args, 'func'):
        args.func(args)
    else:
        parser.print_help()
        sys.exit(1)

if __name__ == '__main__':
    main()
