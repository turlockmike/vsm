#!/usr/bin/env python3
"""
VSM CLI — User-facing command-line interface for the Viable System Machine
"""

import argparse
import json
import os
import sys
import glob
from datetime import datetime
from pathlib import Path
import subprocess

# ANSI color codes
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    RESET = '\033[0m'

def find_vsm_root():
    """Auto-detect VSM_ROOT by looking for core/controller.py"""
    # Check script's directory
    script_dir = Path(__file__).parent.resolve()
    if (script_dir / 'core' / 'controller.py').exists():
        return script_dir

    # Check ~/vsm
    home_vsm = Path.home() / 'vsm'
    if (home_vsm / 'core' / 'controller.py').exists():
        return home_vsm

    # Check ~/projects/vsm/main
    projects_vsm = Path.home() / 'projects' / 'vsm' / 'main'
    if (projects_vsm / 'core' / 'controller.py').exists():
        return projects_vsm

    print(f"{Colors.RED}Error: Could not find VSM installation{Colors.RESET}")
    print(f"Looked in: {script_dir}, {home_vsm}, {projects_vsm}")
    sys.exit(1)

VSM_ROOT = find_vsm_root()
TASKS_DIR = VSM_ROOT / 'sandbox' / 'tasks'
STATE_FILE = VSM_ROOT / 'state' / 'state.json'
LOGS_DIR = VSM_ROOT / 'state' / 'logs'
HEARTBEAT_SCRIPT = VSM_ROOT / 'heartbeat.sh'

def get_next_task_id():
    """Find the next available task ID by scanning existing tasks"""
    task_files = glob.glob(str(TASKS_DIR / '*.json'))
    if not task_files:
        return "001"

    max_id = 0
    for task_file in task_files:
        try:
            with open(task_file, 'r') as f:
                task = json.load(f)
                task_id = int(task.get('id', '0'))
                max_id = max(max_id, task_id)
        except (json.JSONDecodeError, ValueError):
            continue

    return f"{max_id + 1:03d}"

def task_add(args):
    """Add a new task"""
    if not TASKS_DIR.exists():
        TASKS_DIR.mkdir(parents=True, exist_ok=True)

    task_id = get_next_task_id()
    title = args.title
    description = args.description if args.description else title
    priority = args.priority

    task = {
        "id": task_id,
        "priority": priority,
        "title": title,
        "description": description,
        "created": datetime.now().isoformat(timespec='seconds'),
        "status": "pending"
    }

    # Create filename from title (sanitized)
    filename_base = title.lower()[:30].replace(' ', '_')
    filename_base = ''.join(c for c in filename_base if c.isalnum() or c == '_')
    filename = TASKS_DIR / f"{task_id}_{filename_base}.json"

    with open(filename, 'w') as f:
        json.dump(task, f, indent=2)

    print(f"{Colors.GREEN}✓ Task created{Colors.RESET}")
    print(f"  ID: {Colors.BOLD}{task_id}{Colors.RESET}")
    print(f"  Title: {title}")
    print(f"  Priority: {priority}")
    print(f"  File: {filename.name}")

def task_list(args):
    """List all tasks"""
    task_files = sorted(glob.glob(str(TASKS_DIR / '*.json')))

    if not task_files:
        print(f"{Colors.YELLOW}No tasks found{Colors.RESET}")
        return

    tasks = []
    for task_file in task_files:
        try:
            with open(task_file, 'r') as f:
                task = json.load(f)
                tasks.append(task)
        except json.JSONDecodeError:
            continue

    # Sort by priority (lower number = higher priority), then by ID
    tasks.sort(key=lambda t: (t.get('priority', 999), t.get('id', '999')))

    # Print header
    print(f"\n{Colors.BOLD}{'ID':<5} {'PRI':<5} {'STATUS':<12} {'CREATED':<12} {'TITLE'}{Colors.RESET}")
    print("─" * 80)

    # Print tasks
    for task in tasks:
        task_id = task.get('id', '?')
        priority = task.get('priority', '?')
        status = task.get('status', 'unknown')
        created = task.get('created', '')[:10]  # Just the date part
        title = task.get('title', 'Untitled')[:50]  # Truncate long titles

        # Color code status
        if status == 'pending':
            status_colored = f"{Colors.YELLOW}{status:<12}{Colors.RESET}"
        elif status == 'done' or status == 'complete':
            status_colored = f"{Colors.GREEN}{status:<12}{Colors.RESET}"
        elif status == 'in_progress':
            status_colored = f"{Colors.CYAN}{status:<12}{Colors.RESET}"
        else:
            status_colored = f"{status:<12}"

        print(f"{task_id:<5} {priority:<5} {status_colored} {created:<12} {title}")

    print()

def show_status(args):
    """Show system status"""
    if not STATE_FILE.exists():
        print(f"{Colors.RED}Error: State file not found at {STATE_FILE}{Colors.RESET}")
        sys.exit(1)

    with open(STATE_FILE, 'r') as f:
        state = json.load(f)

    print(f"\n{Colors.BOLD}{Colors.BLUE}═══ VSM SYSTEM STATUS ═══{Colors.RESET}\n")

    # Core metrics
    cycle_count = state.get('cycle_count', 0)
    criticality = state.get('criticality', 0)
    last_action = state.get('last_action', 'No action recorded')
    last_success = state.get('last_result_success', None)
    updated = state.get('updated', '')[:19]  # Trim microseconds

    print(f"{Colors.BOLD}Cycle Count:{Colors.RESET}     {cycle_count}")
    print(f"{Colors.BOLD}Criticality:{Colors.RESET}     {criticality:.2f}")
    print(f"{Colors.BOLD}Last Updated:{Colors.RESET}    {updated}")

    # Success indicator
    if last_success is True:
        success_indicator = f"{Colors.GREEN}✓ Success{Colors.RESET}"
    elif last_success is False:
        success_indicator = f"{Colors.RED}✗ Failed{Colors.RESET}"
    else:
        success_indicator = f"{Colors.DIM}Unknown{Colors.RESET}"
    print(f"{Colors.BOLD}Last Result:{Colors.RESET}     {success_indicator}")

    print(f"{Colors.BOLD}Last Action:{Colors.RESET}     {last_action[:70]}")
    if len(last_action) > 70:
        print(f"                {last_action[70:]}")

    # Health metrics
    health = state.get('health', {})
    if health:
        print(f"\n{Colors.BOLD}Health Metrics:{Colors.RESET}")
        disk_free = health.get('disk_free_gb', 0)
        disk_pct = health.get('disk_pct_used', 0)
        mem_available = health.get('mem_available_mb', 0)
        pending_tasks = health.get('pending_tasks', 0)
        cron_installed = health.get('cron_installed', False)

        print(f"  Disk:          {disk_free:.1f} GB free ({disk_pct:.1f}% used)")
        print(f"  Memory:        {mem_available} MB available")
        print(f"  Pending Tasks: {pending_tasks}")
        print(f"  Cron:          {Colors.GREEN if cron_installed else Colors.RED}{'Installed' if cron_installed else 'Not installed'}{Colors.RESET}")

    # Errors
    errors = state.get('errors', [])
    if errors:
        print(f"\n{Colors.BOLD}{Colors.RED}Errors ({len(errors)}):{Colors.RESET}")
        for i, error in enumerate(errors[:5], 1):
            print(f"  {i}. {error}")
        if len(errors) > 5:
            print(f"  ... and {len(errors) - 5} more")
    else:
        print(f"\n{Colors.GREEN}No errors recorded{Colors.RESET}")

    print()

def show_logs(args):
    """Show recent log entries"""
    if not LOGS_DIR.exists():
        print(f"{Colors.RED}Error: Logs directory not found at {LOGS_DIR}{Colors.RESET}")
        sys.exit(1)

    # Filter out heartbeat.log (plain text, not JSON cycle logs)
    log_files = sorted(
        [f for f in glob.glob(str(LOGS_DIR / '*.log')) if not f.endswith('heartbeat.log')],
        key=os.path.getmtime, reverse=True
    )

    if not log_files:
        print(f"{Colors.YELLOW}No logs found{Colors.RESET}")
        return

    limit = args.n if hasattr(args, 'n') and args.n else 5
    log_files = log_files[:limit]

    print(f"\n{Colors.BOLD}{Colors.BLUE}═══ RECENT LOGS (last {len(log_files)}) ═══{Colors.RESET}\n")

    for log_file in log_files:
        try:
            with open(log_file, 'r') as f:
                log_data = json.load(f)

            timestamp = log_data.get('timestamp', '')[:19]
            mode = log_data.get('mode', 'unknown')
            success = log_data.get('success', None)
            summary = log_data.get('summary', 'No summary')
            reason = log_data.get('reason', '')

            # Color code success
            if success is True:
                success_indicator = f"{Colors.GREEN}✓{Colors.RESET}"
            elif success is False:
                success_indicator = f"{Colors.RED}✗{Colors.RESET}"
            else:
                success_indicator = f"{Colors.YELLOW}?{Colors.RESET}"

            print(f"{success_indicator} {Colors.BOLD}{timestamp}{Colors.RESET} [{Colors.CYAN}{mode}{Colors.RESET}]")
            if reason:
                print(f"  Reason: {Colors.DIM}{reason}{Colors.RESET}")

            # Show summary preview (first line or first 100 chars)
            summary_lines = summary.split('\n')
            summary_preview = summary_lines[0][:100]
            print(f"  {summary_preview}")
            if len(summary_lines) > 1:
                print(f"  {Colors.DIM}... (+{len(summary_lines) - 1} more lines){Colors.RESET}")
            print()

        except (json.JSONDecodeError, IOError) as e:
            print(f"{Colors.RED}Error reading {os.path.basename(log_file)}: {e}{Colors.RESET}\n")
            continue

    print()

def run_heartbeat(args):
    """Manually trigger a heartbeat cycle"""
    if not HEARTBEAT_SCRIPT.exists():
        print(f"{Colors.RED}Error: Heartbeat script not found at {HEARTBEAT_SCRIPT}{Colors.RESET}")
        sys.exit(1)

    print(f"{Colors.CYAN}Starting heartbeat cycle...{Colors.RESET}\n")

    try:
        result = subprocess.run(
            ['bash', str(HEARTBEAT_SCRIPT)],
            cwd=str(VSM_ROOT),
            capture_output=False,
            text=True
        )

        if result.returncode == 0:
            print(f"\n{Colors.GREEN}✓ Heartbeat completed{Colors.RESET}")
        else:
            print(f"\n{Colors.RED}✗ Heartbeat failed (exit code {result.returncode}){Colors.RESET}")
            sys.exit(result.returncode)

    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}Interrupted{Colors.RESET}")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Colors.RED}Error running heartbeat: {e}{Colors.RESET}")
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser(
        description='VSM — Viable System Machine CLI',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # Task command group
    task_parser = subparsers.add_parser('task', help='Manage tasks')
    task_subparsers = task_parser.add_subparsers(dest='task_command')

    # task add
    add_parser = task_subparsers.add_parser('add', help='Add a new task')
    add_parser.add_argument('title', help='Task title')
    add_parser.add_argument('--description', help='Task description (defaults to title)')
    add_parser.add_argument('--priority', type=int, default=5, help='Task priority (default: 5)')
    add_parser.set_defaults(func=task_add)

    # task list
    list_parser = task_subparsers.add_parser('list', help='List all tasks')
    list_parser.set_defaults(func=task_list)

    # status
    status_parser = subparsers.add_parser('status', help='Show system status')
    status_parser.set_defaults(func=show_status)

    # logs
    logs_parser = subparsers.add_parser('logs', help='Show recent log entries')
    logs_parser.add_argument('-n', type=int, default=5, help='Number of logs to show (default: 5)')
    logs_parser.set_defaults(func=show_logs)

    # run
    run_parser = subparsers.add_parser('run', help='Manually trigger a heartbeat cycle')
    run_parser.set_defaults(func=run_heartbeat)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    if args.command == 'task' and not args.task_command:
        task_parser.print_help()
        sys.exit(1)

    # Execute the command
    if hasattr(args, 'func'):
        args.func(args)
    else:
        parser.print_help()
        sys.exit(1)

if __name__ == '__main__':
    main()
